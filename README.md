##0、性能：
>・如果不做其他事，理论上可以输出7Hz到60kHz的任意占空比PWM波（0%和100%除外！）<br>
・如果愿意，可将PWM通道拓展到几十个，取决于GPIO口<br>
・但是，输出通道越多、频率越高，越占用CPU（输出到60kHz就基本上不用干别的了。。。），波形越容易不稳定

##1、概况：
>・主程序中只需要包含PWM.h<br>
・PWM_Config.h用来设置一些参数<br>
・其他文件最好不要改动

##2、占用外设资源：
>・整整一个GPIO端口<br>
>>整个端口16根引脚都可以输出独立的PWM

>不会影响AFIO，比如串口等等，常规初始化就可以了。
>>・TIM2<br>
・DMA1的通道5、7（分别是TIM2_CC1，TIM2_CC2的DMA通道）

##3、PWM_Config.h：
设置一些参数
>・RCC_APB2Periph_GPIO_Out：用作输出的GPIO口（默认为GPIOA）			<<<<<<<<特别注意<br>
・MAX_PRESCALER：设置PWM的精度，
>>默认：72M主频下，其值为72，精度为1us<br>
可以设置其他，比如720（10us），7200（0.1ms）等等

>・PWM_NUMBER：缓冲区大小，越小实时性越好，但是CPU中断越频繁

##4、用法：
・首先作底层初始化：
>PWMLowLevelInit(GPIOA B C...)

・然后用：
>PWMChannelApply(序号(0~15)，高电平长度，低电平长度，初相长度，个数(0~65535)）
>>――高低电平长度，从10到65536任设<br>
――其分度在PWM_Config.h中设置，默认是1微秒<br>
――1us精度下总长最好不要短于20，否则波形必乱<br>
――输出频率越高，CPU越会忙于应付中断，波形越容易波动

・通道都注册完了，随时用：
>PWMStart()
>>――很快就会开始输出了

・注册端口，其PWM不会立即生效；等你用PWMStart()，才会统一输出

##5、原理
计算出每个时间段IO口的状态，用定时器触发DMA将计算结果搬运到IO口处<br>
需要同时更新TIM和GPIO，这里用了定时器的两个CCR通道**同时触发两个DMA通道**。<br>
为了保证波形稳定，需要用双缓冲；在DMA传输过半、传输完成的中断中计算半个缓冲区的数据

